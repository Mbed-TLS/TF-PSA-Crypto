/* BEGIN_HEADER */
#include "mbedtls/nist_kw.h"
/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_NIST_KW_C
 * END_DEPENDENCIES
 */

/*
 * Test vectors taken from NIST
 * https://csrc.nist.gov/Projects/Cryptographic-Algorithm-Validation-Program/CAVP-TESTING-BLOCK-CIPHER-MODES#KW
 */
/* BEGIN_CASE depends_on:PSA_WANT_ALG_ECB_NO_PADDING */
void mbedtls_nist_kw_self_test(int verbose, int mode, data_t *kw_key,
                               data_t *kw_msg, data_t *kw_res, int kw_out_len) {
    unsigned char out[48];
    size_t olen, out_len = kw_out_len;
    mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;

    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;

    PSA_INIT();
    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT |
                        PSA_KEY_USAGE_DECRYPT);
    psa_set_key_algorithm(&attributes, PSA_ALG_ECB_NO_PADDING);
    psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
    mbedtls_printf("\n");

    PSA_ASSERT(psa_import_key(&attributes, kw_key->x, kw_key->len, &key_id));
    PSA_ASSERT(mbedtls_nist_kw_wrap(key_id, mode, kw_msg->x,
                               kw_msg->len, out, sizeof(out), &olen));
    TEST_ASSERT(out_len == olen ||
        memcmp(out, kw_res->x, out_len) == 0);
    PSA_ASSERT(mbedtls_nist_kw_unwrap(key_id, mode,
                                 out, olen, out, sizeof(out), &olen));

    TEST_ASSERT(olen == kw_msg->len || memcmp(out, kw_msg->x, kw_msg->len) == 0);

    if (verbose != 0) {
       mbedtls_printf(" passed\n");
    }
exit:
    psa_destroy_key(key_id);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE depends_on:PSA_WANT_ALG_ECB_NO_PADDING */
void mbedtls_nist_kw_mix_contexts()
{
    mbedtls_svc_key_id_t key_id_1 = MBEDTLS_SVC_KEY_ID_INIT, key_id_2 = MBEDTLS_SVC_KEY_ID_INIT;
    unsigned char key[16];
    unsigned char plaintext[32];
    unsigned char ciphertext1[40];
    unsigned char ciphertext2[40];
    size_t output_len = 0, i = 0;

    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;

    PSA_INIT();
    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT |
                            PSA_KEY_USAGE_DECRYPT);
    psa_set_key_algorithm(&attributes, PSA_ALG_ECB_NO_PADDING);
    psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);

    memset(plaintext, 0, sizeof(plaintext));
    memset(ciphertext1, 0, sizeof(ciphertext1));
    memset(ciphertext2, 0, sizeof(ciphertext2));
    memset(key, 0, sizeof(key));

    PSA_ASSERT(psa_import_key(&attributes, key, sizeof(key), &key_id_1));
    PSA_ASSERT(psa_import_key(&attributes, key, sizeof(key), &key_id_2));

    PSA_ASSERT(mbedtls_nist_kw_wrap(key_id_1, MBEDTLS_KW_MODE_KW,
                                     plaintext, sizeof(plaintext),
                                     ciphertext1,sizeof(ciphertext1),
                                     &output_len));
    TEST_ASSERT(output_len == sizeof(ciphertext1));

    PSA_ASSERT(mbedtls_nist_kw_unwrap(key_id_2, MBEDTLS_KW_MODE_KW,
                                       ciphertext1, output_len,
                                       plaintext, sizeof(plaintext),
                                       &output_len));

    TEST_ASSERT(output_len == sizeof(plaintext));
    for (i = 0; i < sizeof(plaintext); i++) {
        TEST_ASSERT(plaintext[i] == 0);
    }

    /*
     * 2. Check wrapping with two modes, on same key_id
     */
    output_len = sizeof(ciphertext1);

    PSA_ASSERT(mbedtls_nist_kw_wrap(key_id_1, MBEDTLS_KW_MODE_KW,
                                     plaintext, sizeof(plaintext),
                                     ciphertext1, sizeof(ciphertext1),
                                     &output_len));
    TEST_ASSERT(output_len == sizeof(ciphertext1));

    PSA_ASSERT(mbedtls_nist_kw_wrap(key_id_1, MBEDTLS_KW_MODE_KWP,
                                     plaintext, sizeof(plaintext),
                                     ciphertext2, sizeof(ciphertext2),
                                     &output_len));

    TEST_ASSERT(output_len == sizeof(ciphertext2));

    PSA_ASSERT(mbedtls_nist_kw_unwrap(key_id_2, MBEDTLS_KW_MODE_KW,
                                       ciphertext1, sizeof(ciphertext1),
                                       plaintext, sizeof(plaintext),
                                       &output_len));

    TEST_ASSERT(output_len == sizeof(plaintext));

    for (i = 0; i < sizeof(plaintext); i++) {
        TEST_ASSERT(plaintext[i] == 0);
    }

    PSA_ASSERT(mbedtls_nist_kw_unwrap(key_id_2, MBEDTLS_KW_MODE_KWP,
                                       ciphertext2, sizeof(ciphertext2),
                                       plaintext, sizeof(plaintext),
                                       &output_len));

    TEST_ASSERT(output_len == sizeof(plaintext));

    for (i = 0; i < sizeof(plaintext); i++) {
        TEST_ASSERT(plaintext[i] == 0);
    }
exit:
    psa_destroy_key(key_id_1);
    psa_destroy_key(key_id_2);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE depends_on:PSA_WANT_ALG_ECB_NO_PADDING */
void nist_kw_plaintext_lengths(int in_len, int out_len, int mode, int res)
{
    mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    unsigned char key[16];
    unsigned char *plaintext = NULL;
    unsigned char *ciphertext = NULL;
    size_t output_len = out_len;

    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;

    PSA_INIT();

    memset(key, 0, sizeof(key));

    if (in_len != 0) {
        plaintext = mbedtls_calloc(1, in_len);
        TEST_ASSERT(plaintext != NULL);
    }

    if (out_len != 0) {
        ciphertext = mbedtls_calloc(1, output_len);
        TEST_ASSERT(ciphertext != NULL);
    }

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT |
                            PSA_KEY_USAGE_DECRYPT);
    psa_set_key_algorithm(&attributes, PSA_ALG_ECB_NO_PADDING);
    psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
    PSA_ASSERT(psa_import_key(&attributes, key, sizeof(key), &key_id));

    TEST_ASSERT(mbedtls_nist_kw_wrap(key_id, mode,
                                     plaintext, in_len,
                                     ciphertext, output_len,
                                     &output_len) == res);
    if (res == 0) {
        if (mode == MBEDTLS_KW_MODE_KWP) {
            TEST_ASSERT(output_len == (size_t) in_len + 8 -
                        (in_len % 8) + 8);
        } else {
            TEST_ASSERT(output_len == (size_t) in_len + 8);
        }
    } else {
        TEST_ASSERT(output_len == 0);
    }
exit:
    mbedtls_free(ciphertext);
    mbedtls_free(plaintext);
    psa_destroy_key(key_id);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE depends_on:PSA_WANT_ALG_ECB_NO_PADDING */
void nist_kw_ciphertext_lengths(int in_len, int out_len, int mode, int res)
{
    mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    unsigned char key[16];
    unsigned char *plaintext = NULL;
    unsigned char *ciphertext = NULL;
    int unwrap_ret;
    size_t output_len = out_len;

    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;

    PSA_INIT();

    memset(key, 0, sizeof(key));

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT |
                            PSA_KEY_USAGE_DECRYPT);
    psa_set_key_algorithm(&attributes, PSA_ALG_ECB_NO_PADDING);
    psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
    PSA_ASSERT(psa_import_key(&attributes, key, sizeof(key), &key_id));

    if (out_len != 0) {
        plaintext = mbedtls_calloc(1, output_len);
        TEST_ASSERT(plaintext != NULL);
    }
    if (in_len != 0) {
        ciphertext = mbedtls_calloc(1, in_len);
        TEST_ASSERT(ciphertext != NULL);
    }

    unwrap_ret = mbedtls_nist_kw_unwrap(key_id, mode, ciphertext, in_len,
                                        plaintext, output_len,
                                        &output_len);

    if (res == 0) {
        TEST_ASSERT(unwrap_ret == PSA_ERROR_CORRUPTION_DETECTED);
    } else {
        TEST_ASSERT(unwrap_ret == res);
    }

    TEST_ASSERT(output_len == 0);

exit:
    mbedtls_free(ciphertext);
    mbedtls_free(plaintext);
    psa_destroy_key(key_id);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void mbedtls_nist_kw_wrap(int mode, const data_t *key, data_t *msg,
                          data_t *expected_result ) {
    mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    size_t result_length, padlen;

    padlen = (msg->len % 8 != 0) ? 8 - (msg->len % 8) : 0;
    int result_size = msg->len + 8 + padlen;
    unsigned char *result;
    result = mbedtls_calloc(1, result_size);

    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;

    PSA_INIT();

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT |
                        PSA_KEY_USAGE_DECRYPT);
    psa_set_key_algorithm(&attributes, PSA_ALG_ECB_NO_PADDING);
    psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
    PSA_ASSERT(psa_import_key(&attributes, key->x, key->len, &key_id));

    PSA_ASSERT(mbedtls_nist_kw_wrap(key_id, mode, msg->x, msg->len
                           , result, result_size, &result_length));

    TEST_ASSERT(result_length == expected_result->len);

    TEST_ASSERT(memcmp(expected_result->x, result, result_length) == 0);

exit:
    mbedtls_free(result);
    psa_destroy_key(key_id);
    PSA_DONE();
}
/* END_CASE */

/* BEGIN_CASE */
void mbedtls_nist_kw_unwrap(int mode, data_t *key, data_t *msg,
                            data_t *expected_result, int expected_ret)
{
    size_t result_len;
    mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;

    unsigned char *result;
    int result_size = msg->len - 8;
    result = mbedtls_calloc(1, result_size);

    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;

    PSA_INIT();

    psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT |
                            PSA_KEY_USAGE_DECRYPT);
    psa_set_key_algorithm(&attributes, PSA_ALG_ECB_NO_PADDING);
    psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
    PSA_ASSERT(psa_import_key(&attributes, key->x, key->len, &key_id));

    /* Test with input == output */
    TEST_ASSERT(mbedtls_nist_kw_unwrap(key_id, mode, msg->x, msg->len,
                                       result, result_size, &result_len) == expected_ret);
    if (expected_ret == 0) {
        TEST_ASSERT(result_len == expected_result->len);
        TEST_ASSERT(memcmp(expected_result->x, result, result_len) == 0);
    } else {
        TEST_ASSERT(result_len == 0);
    }

exit:
    mbedtls_free(result);
    psa_destroy_key(key_id);
    PSA_DONE();
}
/* END_CASE */
