#!/usr/bin/env python3

"""Makefile generator for TF-PSA-Crypto.
"""

# Copyright The Mbed TLS Contributors
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import os
import pathlib
import sys
from typing import Optional, Union

from mbedtls_dev import typing_util


class MakefileMaker:
    """Generate a makefile for TF-PSA-Crypto.

    Typical usage:
        MakefileMaker(options, source_path).generate()
    """

    def __init__(self, options, source_path: str) -> None:
        """Initialize a makefile generator.

        options is the command line option object.

        source_path is a path to the root of the source directory,
        absolute or relative to the root of the build directory,
        and not containing characters that are special to shell or make.
        """
        # The root of the build tree.
        self.build_dir = options.dir #type: str
        # A path to the source tree, from the generator's working directory.
        self.source_path = pathlib.Path(options.source) #type: pathlib.Path
        # A path to the source tree, from the root of the build tree.
        self.source_from_build = pathlib.Path(source_path) #type: pathlib.Path

        # While generating, the output stream
        self.out = None #type: Optional[typing_util.Writable]

    def line(self, text: str) -> None:
        """Emit a makefile line."""
        assert self.out is not None
        self.out.write(text + '\n')

    def blank_line(self) -> None:
        """Emit a blank line."""
        self.line('')

    def comment(self, text) -> None:
        """Emit a makefile comment line containing the given text."""
        self.line('## ' + text)

    def output_all(self) -> None:
        """Generate the makefile content."""
        self.comment('Generated by ' + ' '.join(sys.argv))
        self.comment('Do not edit this file! All modifications will be lost.')
        self.blank_line()
        self.comment('End of generated file.')

    def generate(self) -> None:
        """Generate the makefile."""
        destination = os.path.join(self.build_dir, 'Makefile')
        temp_file = destination + '.new'
        with open(temp_file, 'w', encoding='ascii') as out:
            try:
                self.out = out
                self.output_all()
            finally:
                self.out = None
        os.replace(temp_file, destination)


class BuildTreeMaker:
    """Prepare a TF-PSA-Crypto build tree.

    * Create a directory structure.
    * Create symbolic links to some files and directories from the source.
    * Create a Makefile.

    Typical usage: BuildTreeMaker(options).run()
    """

    def __init__(self, options) -> None:
        """Instantiate from command line options."""
        self.source_dir = options.source #type: str
        self.build_dir = options.dir #type: str
        # In-tree or out-of-tree build?
        self.in_tree = \
            (os.path.exists(self.build_dir) and
             os.path.samefile(self.build_dir, self.source_dir)) #type: bool
        self.makefile = MakefileMaker(options,
                                      os.curdir if self.in_tree else 'source')


    def source_from_build_root(self) -> str:
        """A path to the source root, either absolute or relative to the build root."""
        # If the build tree is a direct subdirectory of the source tree
        # (a common case), prefer a relative path. This allows moving
        # the source tree (which includes the build tree), and the build
        # tree will still work.
        if os.path.samefile(self.source_dir,
                            os.path.join(self.build_dir, os.path.pardir)):
            return os.path.pardir
        # Default to using an absolute path. This is safe except if the source
        # tree is moved.
        return os.path.abspath(self.source_dir)

    def make_link(self, target: str, link: str) -> None:
        """Create a symbolic link called link pointing to target.

        link is a path relative to the build directory.

        If the link already exists, it is not modified.
        """
        link_path = os.path.join(self.build_dir, link)
        if not os.path.lexists(link_path):
            os.symlink(target, link_path)

    def make_directory(self, sub_path: Union[pathlib.Path, str]) -> None:
        """Create a subdirectory of the build tree.

        Create parents if necessary.
        Do nothing if the specified directory already exists.
        """
        path = pathlib.Path(self.build_dir).joinpath(sub_path)
        if not path.exists():
            os.makedirs(str(path))

    def create_build_tree(self) -> None:
        """Create directories and links needed for an out-of-tree build."""
        # Source files are referenced as "source/..." rather than a
        # path to the source directory to make it easier to move the
        # source directory, and avoid any difficulty with special characters
        # such as spaces in paths.
        self.make_link(self.source_from_build_root(), 'source')
        # Create directories to override headers
        source_path = pathlib.Path(self.source_dir)
        for path in source_path.glob('include/*'):
            if path.is_dir():
                self.make_directory(path.relative_to(source_path))
        # Link to some source directories expected by scripts or programs.
        for link in [
                ['scripts'],
        ]:
            self.make_link(os.path.join(*([os.pardir] * (len(link) - 1) +
                                          ['source'] + link)),
                           os.path.join(*link))

    def run(self) -> None:
        """Create the build tree and the makefile."""
        if not os.path.exists(self.build_dir):
            os.mkdir(self.build_dir)
        self.makefile.generate()
        if not self.in_tree:
            self.create_build_tree()


def main() -> None:
    """Process the command line and prepare a build tree accordingly."""
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('--dir', '-d',
                        default=os.curdir,
                        help='Build directory to create (default: current directory)')
    parser.add_argument('--source', '-s',
                        default=os.curdir,
                        help='Root directory of the source tree (default: current directory)')
    options = parser.parse_args()
    builder = BuildTreeMaker(options)
    builder.run()


if __name__ == '__main__':
    main()
