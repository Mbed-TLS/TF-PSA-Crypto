#!/usr/bin/env python3

"""Makefile generator for TF-PSA-Crypto.
"""

# Copyright The Mbed TLS Contributors
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import os
import pathlib
import sys
from typing import Dict, Iterable, Optional, Set, Union

from mbedtls_dev import typing_util


class MakefileMaker:
    """Generate a makefile for TF-PSA-Crypto.

    Typical usage:
        MakefileMaker(options, source_path).generate()
    """

    def __init__(self, options, source_path: str) -> None:
        """Initialize a makefile generator.

        options is the command line option object.

        source_path is a path to the root of the source directory,
        absolute or relative to the root of the build directory,
        and not containing characters that are special to shell or make.
        """

        # The root of the build tree.
        self.build_dir = options.dir #type: str
        # A path to the source tree, from the generator's working directory.
        self.source_path = pathlib.Path(options.source) #type: pathlib.Path
        # A path to the source tree, from the root of the build tree.
        self.source_from_build = pathlib.Path(source_path) #type: pathlib.Path

        # {target: help_text}
        self.help = {} #type: Dict[str, str]
        # Directories containing targets
        self.target_directories = set() #type: Set[str]
        # While generating, the output stream
        self.out = None #type: Optional[typing_util.Writable]

    #### Helpers for output generation ####

    def line(self, text: str) -> None:
        """Emit a makefile line."""
        assert self.out is not None
        self.out.write(text + '\n')

    def blank_line(self) -> None:
        """Emit a blank line."""
        self.line('')

    def comment(self, text) -> None:
        """Emit a makefile comment line containing the given text."""
        self.line('## ' + text)

    def help_lines(self) -> Iterable[str]:
        """Return the lines of text to show for the 'help' target."""
        return ['{:<14} : {}'.format(name, self.help[name])
                for name in sorted(self.help.keys())]

    def add_dependencies(self, name: str, *dependencies: str) -> None:
        """Emit a dependency line for the target name."""
        # Put one dependency per physical line if the whole list is very long.
        parts = (name + ':',) + dependencies
        simple = ' '.join(parts)
        if len(simple) < 80:
            self.line(simple)
        else:
            self.line(' \\\n\t\t'.join(parts))

    def target(self, # pylint: disable=too-many-arguments
               name: str,
               dependencies: Iterable[str],
               commands: Iterable[str],
               help_text: Optional[str] = None,
               phony=False,
               ) -> None:
        """Generate a makefile rule.

        * name: the target of the rule.
        * dependencies: a list of dependencies.
        * commands: a list of commands to run (the recipe).
        * help_text: documentation to show for this target in "make help".
          If this is omitted, the target is not listed in "make help".
        * phony: if true, declare this target as phony.
        """
        if not phony:
            self.target_directories.add(os.path.dirname(name))
        self.add_dependencies(name, *dependencies)
        for com in commands:
            self.line('\t' + com.strip('\n').replace('\n', ' \\\n\t'))
        if help_text is not None:
            self.help[name] = help_text
        if phony:
            self.line('.PHONY: ' + name)

    #### Generate makefile sections ####

    def output_all(self) -> None:
        """Generate the makefile content."""
        self.comment('Generated by ' + ' '.join(sys.argv))
        self.comment('Do not edit this file! All modifications will be lost.')
        self.blank_line()
        # The help target must come last because it displays accumulated help
        # text set by previous calls to self.target. Set its own help manually
        # because self.target would set it too late for it to be printed.
        self.help['help'] = 'Show this help listing the most commonly-used non-file targets.'
        self.target('help', [],
                    ['@echo "{}"'.format(line) for line in self.help_lines()],
                    phony=True)
        self.blank_line()
        self.comment('End of generated file.')

    def generate(self) -> None:
        """Generate the makefile."""
        destination = os.path.join(self.build_dir, 'Makefile')
        temp_file = destination + '.new'
        with open(temp_file, 'w', encoding='ascii') as out:
            try:
                self.out = out
                self.output_all()
            finally:
                self.out = None
        os.replace(temp_file, destination)


class BuildTreeMaker:
    """Prepare a TF-PSA-Crypto build tree.

    * Create a directory structure.
    * Create symbolic links to some files and directories from the source.
    * Create a Makefile.

    Typical usage: BuildTreeMaker(options).run()
    """

    def __init__(self, options) -> None:
        """Instantiate from command line options."""
        self.source_dir = options.source #type: str
        self.build_dir = options.dir #type: str
        # In-tree or out-of-tree build?
        self.in_tree = \
            (os.path.exists(self.build_dir) and
             os.path.samefile(self.build_dir, self.source_dir)) #type: bool
        self.makefile = MakefileMaker(options,
                                      os.curdir if self.in_tree else 'source')


    def source_from_build_root(self) -> str:
        """A path to the source root, either absolute or relative to the build root."""
        # If the build tree is a direct subdirectory of the source tree
        # (a common case), prefer a relative path. This allows moving
        # the source tree (which includes the build tree), and the build
        # tree will still work.
        if os.path.samefile(self.source_dir,
                            os.path.join(self.build_dir, os.path.pardir)):
            return os.path.pardir
        # Default to using an absolute path. This is safe except if the source
        # tree is moved.
        return os.path.abspath(self.source_dir)

    def make_link(self, target: str, link: str) -> None:
        """Create a symbolic link called link pointing to target.

        link is a path relative to the build directory.

        If the link already exists, it is not modified.
        """
        link_path = os.path.join(self.build_dir, link)
        if not os.path.lexists(link_path):
            os.symlink(target, link_path)

    def make_directory(self, sub_path: Union[pathlib.Path, str]) -> None:
        """Create a subdirectory of the build tree.

        Create parents if necessary.
        Do nothing if the specified directory already exists.
        """
        path = pathlib.Path(self.build_dir).joinpath(sub_path)
        if not path.exists():
            os.makedirs(str(path))

    def create_build_tree(self) -> None:
        """Create directories and links needed for an out-of-tree build."""
        # Source files are referenced as "source/..." rather than a
        # path to the source directory to make it easier to move the
        # source directory, and avoid any difficulty with special characters
        # such as spaces in paths.
        self.make_link(self.source_from_build_root(), 'source')
        # Create directories to override headers
        source_path = pathlib.Path(self.source_dir)
        for path in source_path.glob('include/*'):
            if path.is_dir():
                self.make_directory(path.relative_to(source_path))
        # Create directories containing targets
        for directory in self.makefile.target_directories:
            self.make_directory(directory)
        # Link to some source directories expected by scripts or programs.
        for link in [
                ['scripts'],
        ]:
            self.make_link(os.path.join(*([os.pardir] * (len(link) - 1) +
                                          ['source'] + link)),
                           os.path.join(*link))

    def run(self) -> None:
        """Create the build tree and the makefile."""
        if not os.path.exists(self.build_dir):
            os.mkdir(self.build_dir)
        self.makefile.generate()
        if not self.in_tree:
            self.create_build_tree()


def main() -> None:
    """Process the command line and prepare a build tree accordingly."""
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('--dir', '-d',
                        default=os.curdir,
                        help='Build directory to create (default: current directory)')
    parser.add_argument('--source', '-s',
                        default=os.curdir,
                        help='Root directory of the source tree (default: current directory)')
    options = parser.parse_args()
    builder = BuildTreeMaker(options)
    builder.run()


if __name__ == '__main__':
    main()
